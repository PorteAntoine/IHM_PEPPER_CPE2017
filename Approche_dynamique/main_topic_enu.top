topic: ~main_topic_enu() 
language: enu 
concept:(located) [room situated placed located find] 
concept:(where_is) ["where is" where's "where are" "where can I"] 
concept:(can_you)[ "[can will could] you {please}" "do you think you could" "are you [ready able] to" "do you know how to"] 
concept:(what_is) [{"~can_you tell me" "do you know" "tell me"} [ what's "what [is are was were]"] ]
concept:(which_is) [~what_is "which is" "{To} which"]
concept:(heaviest) [heaviest "most important weight"] 
concept:(lightest) [lightest "less important weight"] 
concept:(biggest) [biggest  "most important [size dimension]"] 
concept:(smallest) [smallest little tiny tiniest "less important [size dimension]"] 
concept:(how_many) ["how many" "how much" "~what_is the number of"]
concept:(that) [that those these there]
concept:(which) ["{To} what" "{To} which"]
concept:(belongTo)  ["belongs to" "belong to" "is present" "belonging" "[are is]{[in on]}"] #Ajouter on is etc
concept:(location) [localization location position room place]

dynamic: object 
dynamic: category 
dynamic: color 
dynamic: type 
dynamic: localization
dynamic: localizationBeacon
dynamic: room
dynamic: shape
dynamic: size
dynamic: weight
dynamic: allAttributs

#Est ce qu'un objet existe
u: (["do you have _~object" "[is are] {~that} _~object"]) yes off course I have $1

#Quelle est la couleur de <objet>
u: (~what_is {the} color {of} {the} _~object) The color of the $1 is ^call(ALKnowledge.getObject("knowledge", $1, "hasColor"))
c1:(_*)  $1 

#Ou est <objet>
u: (["~where_is {~located}" "~what_is {the} ~location"] {of} {the} _~object) The $1 is ^call(ALKnowledge.getObject("knowledge", $1, "isintheroom")) ^call(ALKnowledge.getObject("knowledge", $1, "islocated"))
c1:(_*) in the $1 

#quelle est la categorie de <objet>
u:(~which_is {the} category {of} {for} {the} _~object) The category of $1 is ^call(ALKnowledge.getObject("knowledge", $1, "belongstocategory"))
c1:(_*)  $1 

#quel est le type de <objet>
u:(~which_is {the} type {of} {for} {the} _~object) The type of $1 is ^call(ALKnowledge.getObject("knowledge", $1, "isoftype"))
c1:(_*)  $1

#quel est le poid de <objet>
u:(~which_is {the} {default} {"most probable"} weight {of} {for} {the} _~object) The weight of $1 is ^call(ALKnowledge.getObject("knowledge", $1, "weight"))
c1:(_*)  $1 

#quelle est la taille de <objet>
u:(~which_is {the} {default} {"most probable"} size {of} {for} {the} _~object) The size of $1 is ^call(ALKnowledge.getObject("knowledge", $1, "size"))
c1:(_*)  $1 

#quels objects possedent l'attribut
u:(~which_is {the} {objects} {that} ~belongTo {the} {in}_~allAttributs ) are $1  ^call(ProcessObjectModule.hasAttribute($1))

#Quel sont les objets les plus lourd dans <categorie>
u: (~which_is {the} {most} ~heaviest _~category) the heaviest $1 ^call(ProcessObjectModule.heaviestattr($1))
c1:(_*) is $1

#Quel sont les objets les plus lourd dans <type>
u: (~which_is {the} {most} ~heaviest _~type) the heaviest $1 ^call(ProcessObjectModule.heaviestattr($1))
c1:(_*) is $1

#Quel sont les objets les plus lourd dans la liste d'objects
u: (~which_is {the} {most} ~heaviest object)  the heaviest object ^call(ProcessObjectModule.heaviest(^enumerate(~object)))
c1:(_*) is $1  

#Quel sont les objets les plus leger dans <type>
u: (~which_is {the} {most} ~lightest _~type) the lightest $1 ^call(ProcessObjectModule.lightestattr($1))
c1:(_*) is $1
 
#Quel sont les objets les plus leger dans <categorie>
u: (~which_is {the} {most} ~lightest _~category) the lightest $1 ^call(ProcessObjectModule.lightestattr($1))
c1:(_*) is $1

#Quel sont les objets les plus leger dans la liste des objects
u: (~which_is {the} {most} ~lightest object)  the lightest object ^call(ProcessObjectModule.lightest(^enumerate(~object)))
c1:(_*) is $1  

#Quel sont les objets les plus grand dans <type>
u: (~which_is {the} {most} ~biggest _~type) the biggest $1 ^call(ProcessObjectModule.biggestattr($1))
c1:(_*) is $1

#Quel sont les objets les plus grand dans <category>
u: (~which_is {the} {most} ~biggest _~category) the biggest $1 ^call(ProcessObjectModule.biggestattr($1))
c1:(_*) is $1

#Quel sont les objets les plus grand dans la liste des objects
u: (~which_is {the} {most} ~biggest object)  the biggest object ^call(ProcessObjectModule.biggest(^enumerate(~object)))
c1:(_*) is $1 

#Quel sont les objets les plus petit dans <type>
u: (~which_is {the} {most} ~smallest _~type) the smallest $1 ^call(ProcessObjectModule.littleattr($1))
c1:(_*) is $1

#Quel sont les objets les plus petit dans <categorie>
u: (~which_is {the} {most} ~smallest _~category) the smallest $1 ^call(ProcessObjectModule.littleattr($1))
c1:(_*) is $1


#Quel sont les objets les plus petit dans la liste des objects
u: (~which_is {the} {most} ~smallest object)  the smallest object ^call(ProcessObjectModule.little(^enumerate(~object)))
c1:(_*) is $1 

#quel sont les categories de la robocup ? 
u: (~which_is {all} {the} categories {of} {the} {Robocup}) This year the categories are ^enumerate(~category)

#quel sont les types de la robocup ? 
u: (~which_is {all} {the} types {of} {the} {Robocup}) This year the types are ^enumerate(~type)

#quel sont les piece de la robocup ? 
u: (~which_is {all} {the} rooms {of} {the} {Robocup}) This year the rooms are ^enumerate(~room)

# est ce que l'objet 1 et l'objet 2 appartiennent a la meme categorie
u: ([do are is] {the} {category} {of} _~object and _~object {["belong to" in]} the same {category})  $1 and $2 ^call(ProcessObjectModule.sameCategory($1,$2))
c1:(True) are in the same category  
c1:(False) are not in the same category

# est ce que l'objet 1 et l'objet 2 appartiennent au meme type
u: ([do does are is] {the} {type} {of} _~object and _~object {["belong to" in]} the same {type})  $1 and $2 ^call(ProcessObjectModule.sameType($1,$2))
c1:(True) have the same type
c1:(False) have not the same type

# est ce que l'objet 1 et l'objet 2 se trouvent dans la meme salle
u: ([do are is] {the} {room} {of} _~object and _~object {["belong to" in "~located {in}"]} the same {~location})  $1 and $2 ^call(ProcessObjectModule.sameRoom($1,$2))
c1:(True) are in the same room
c1:(False) are not in the same room

# est ce que l'objet 1 et l'objet 2 ont la meme couleur
u: ([do are is] {the} {color} {of} _~object and _~object {have} {of} the same {color})  $1 and $2 ^call(ProcessObjectModule.sameColor($1,$2))
c1:(True) have the same color
c1:(False) have not the same color

# est ce que l'objet 1 et l'objet 2 ont le meme poids
u: ([do are is] {the} {weight} {of} _~object and _~object {have} {of} the same {weight})  $1 and $2 ^call(ProcessObjectModule.sameWeight($1,$2))
c1:(True) have the same weight
c1:(False) have not the same weight

# est ce que l'objet 1 et l'objet 2 ont la meme taille
u: ([do are is] {the} {size} {of} _~object and _~object {have} {of} the same {size})  $1 and $2 ^call(ProcessObjectModule.sameSize($1,$2))
c1:(True) have the same size
c1:(False) have not the same size

# est ce que l'objet 1 et l'objet 2 ont le meme localisation
u: ([do are is] {the} {localization} {of} _~object and _~object {have} {of} the same container)  $1 and $2 ^call(ProcessObjectModule.sameLocalization($1,$2))
c1:(True) have the same localization
c1:(False) have not the same localization

# combien d'objets possedent un attribut
u: (~how_many {objects} {~that} {are} {in} {the} {category} _~allAttributs {are} {~that})$attribut=$1 there are ^call(ProcessObjectModule.numberAttribute($1))
c1:(_*) $1 $attribut objects

# quel est le plus lourd objet entre objet1 et objet2
u: ({~which_is} {the} {~heaviest} {object} between {the}  _~object and {the} _~object {what} {is} {the} {~heaviest}) the heaviest is ^call(ProcessObjectModule.heavyName($1,$2))
c1:(_*) $1

# quel est le plus leger objet entre objet1 et objet2
u: ({~which_is} {the} {~lightest} {object} between {the}  _~object and {the} _~object {what} {is} {the} {~lightest}) the lightest is ^call(ProcessObjectModule.lightName($1,$2))
c1:(_*) $1

# quel est le plus petit objet entre objet1 et objet2
u: ({~which_is} {the} {~smallest} {object} between {the}  _~object and {the} _~object {what} {is} {the} {~smallest}) the smallest is ^call(ProcessObjectModule.littleName($1,$2))
c1:(_*) $1

# quel est le plus grand objet entre objet1 et objet2
u: ({~which_is} {the} {~biggest} {object} between {the}  _~object and {the} _~object {what} {is} {the} {~biggest}) the biggest is ^call(ProcessObjectModule.bigName($1,$2))
c1:(_*) $1

# quelle est la liste d'objet possedant les attributs 1 et 2
u: (~which_is {the} {objects} {that} {are} _~allAttributs {and} _~allAttributs) are the objects that are $1 and $2 ^call(ProcessObjectModule.hasTwoAttribute($1,$2))

u: ([Hi Hello "hey {there}" "good [morning afternoon evening]"] {pepper}) Hello Human, how are you?
    u1:(["I'm fine too" "{"I'm"} fine {thank} {thanks} {you}" "I'm good" "I feel {very} well"]) very good
    u1:(["I'm not feeling well" "{no} I'm not" "I don't feel {very} well" "I'm not {very} fine" "not {too} [good fine]"]) oh this sad

u: (How [are do] you {do} {doing} {pepper}) I'm fine thanks, and you?
    u1:(["I'm fine too" "{"I'm"} fine {thank} {thanks} {you}" "I'm good" "I feel {very} well" "{thanks} me too"]) very good
    u1:(["I'm not feeling well" "{no} I'm not {very} {really} {fine}" "I don't feel {very} well" "not {too} [good fine]"]) oh this sad

u: (["~what_is your name" "how should [I we] call you"]) my name is pepper, and you?
    u1:(["my name is" "I am" "I'm"]) Ok nice to meet you!

u: (Good bye {pepper}) good bye !
